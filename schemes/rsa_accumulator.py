from typing import Any
from Crypto.Util import number

from .base_scheme import AccumulatorScheme
from utils.crypto import prime_representatives, product, get_hash

# --- Simulated Trusted Setup ---
# In a real system, N would be generated by a trusted party, and its
# factorization (p, q) would be destroyed. For this simulation, we generate
# it once and use it as a global constant.
RSA_MODULUS_BITS = 2048
p = number.getPrime(RSA_MODULUS_BITS // 2)
q = number.getPrime(RSA_MODULUS_BITS // 2)
while p == q:
    q = number.getPrime(RSA_MODULUS_BITS // 2)
N = p * q
G = 3 # A common generator
# This is the trapdoor, only to be used by the trapdoored version.
PHI_N = (p - 1) * (q - 1)
# --- End Simulated Trusted Setup ---

PRIME_BITS = 128 # The size of primes representing elements

class RsaAccumulator(AccumulatorScheme):
    """
    A dynamic RSA Accumulator in a trapdoor-free setting.
    - Simulates a trusted setup for the modulus N.
    - Elements are mapped to unique prime numbers.
    - NOTE: `prove_membership` is implemented inefficiently (O(N)) for simplicity.
      A full implementation would update witnesses alongside the accumulator.
    - NOTE: `update` is O(N) as it recomputes the accumulator without the trapdoor.
    """

    def __init__(self, state: list[bytes]):
        super().__init__(state)
        self.prime_map: dict[bytes, int] = {} 
        self.accumulator = G

    def _map_to_primes(self, elements: list[bytes]):
        """Maps elements to primes and stores them."""
        hashes = [get_hash(e) for e in elements]
        new_primes = prime_representatives([h for h in hashes if h not in self.prime_map], PRIME_BITS)
        
        new_prime_idx = 0
        for h in hashes:
            if h not in self.prime_map:
                self.prime_map[h] = new_primes[new_prime_idx]
                new_prime_idx += 1

    def create(self):
        self._map_to_primes(self.state)
        
        if not self.state:
            self.accumulator = G
            return

        prime_prod = product([self.prime_map[get_hash(s)] for s in self.state])
        self.accumulator = pow(G, prime_prod, N)

    def prove_membership(self, element: bytes) -> int | None:
        element_hash = get_hash(element)
        if element_hash not in self.prime_map:
            return None 

        other_primes_prod = product([self.prime_map[get_hash(s)] for s in self.state if get_hash(s) != element_hash])
        witness = pow(G, other_primes_prod, N)

        return witness

    def verify_membership(self, element: bytes, proof: int) -> bool:
        element_hash = get_hash(element)
        if element_hash not in self.prime_map:
            self._map_to_primes([element])

        x = self.prime_map[element_hash]
        witness = proof
        
        return pow(witness, x, N) == self.accumulator

    def update(self, old_element: bytes, new_element: bytes):
        """
        Updates the accumulator by replacing one element with another.
        Since we don't know phi(N), we must recompute the full product.
        """
        try:
            idx = self.state.index(old_element)
            self.state[idx] = new_element
        except ValueError:
            return
        
        self._map_to_primes([new_element])

        old_hash = get_hash(old_element)
        if old_hash in self.prime_map:
            del self.prime_map[old_hash]
        
        prime_prod = product([self.prime_map[get_hash(s)] for s in self.state])
        self.accumulator = pow(G, prime_prod, N)

class RsaAccumulatorTrapdoored(RsaAccumulator):
    """
    An RSA Accumulator that uses the trapdoor (phi_n) for efficient
    batch updates. This represents a scenario with a trusted prover.
    """
    def __init__(self, state: list[bytes]):
        super().__init__(state)
        self.phi_n = PHI_N

    def update(self, old_element: bytes, new_element: bytes):
        """
        Adapts the single update call to the batch update method.
        In benchmarks, we will call batch_update directly for efficiency.
        """
        self.batch_update(additions=[new_element], deletions=[old_element])

    def batch_update(self, additions: list[bytes], deletions: list[bytes]):
        """
        Efficiently updates the accumulator using the trapdoor.
        O(k) where k is the number of updates, instead of O(N).
        """
        add_prod = 1
        if additions:
            self._map_to_primes(additions)
            add_prod = product([self.prime_map[get_hash(s)] for s in additions])

        inv_del_prod = 1
        if deletions:
            deleted_hashes = {get_hash(d) for d in deletions}
            primes_to_remove = [self.prime_map[h] for h in deleted_hashes if h in self.prime_map]
            
            if primes_to_remove:
                del_prod = product(primes_to_remove)
                inv_del_prod = pow(del_prod, -1, self.phi_n)
        
        update_exponent = (add_prod * inv_del_prod) % self.phi_n
        self.accumulator = pow(self.accumulator, update_exponent, N)

        current_state_set = set(self.state)
        current_state_set.difference_update(deletions)
        current_state_set.update(additions)
        self.state = list(current_state_set)
        
        deleted_hashes_for_map = {get_hash(d) for d in deletions}
        for h in deleted_hashes_for_map:
            if h in self.prime_map:
                del self.prime_map[h] 