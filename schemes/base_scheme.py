from abc import ABC, abstractmethod
from typing import Any

class AccumulatorScheme(ABC):
    """
    Abstract Base Class for a cryptographic accumulator scheme.
    Defines the common interface for all schemes to be benchmarked.
    """

    @abstractmethod
    def __init__(self, state: list[bytes]):
        """
        Initializes the accumulator with a given state.
        
        :param state: A list of byte strings representing the initial state elements.
        """
        self.state = state
        self.accumulator: Any = None

    @abstractmethod
    def create(self):
        """
        Creates the accumulator from the initial state.
        """
        pass

    @abstractmethod
    def prove_membership(self, element: bytes) -> Any:
        """
        Generates a membership proof for a given element.

        :param element: The element to prove membership for.
        :return: A proof object, or None if the element is not in the state.
        """
        pass

    @abstractmethod
    def verify_membership(self, element: bytes, proof: Any) -> bool:
        """
        Verifies a membership proof.

        :param element: The element whose membership is being verified.
        :param proof: The proof object generated by prove_membership.
        :return: True if the proof is valid, False otherwise.
        """
        pass

    @abstractmethod
    def update(self, old_element: bytes, new_element: bytes):
        """
        Updates the accumulator by replacing one element with another.

        :param old_element: The element to be removed from the state.
        :param new_element: The element to be added to the state.
        """
        pass

    def get_proof_size(self, proof: Any) -> int:
        """
        Calculates the size of a proof in bytes.
        This is a default implementation that can be overridden if the proof
        is not a simple byte string or list of byte strings.
        """
        if isinstance(proof, bytes):
            return len(proof)
        if isinstance(proof, int):
            return (proof.bit_length() + 7) // 8
        if isinstance(proof, list):
            return sum(self.get_proof_size(p) for p in proof)
        if isinstance(proof, tuple):
             return sum(self.get_proof_size(p) for p in proof)
        if hasattr(proof, '__dict__'):
            return sum(self.get_proof_size(value) for value in proof.__dict__.values())
        if proof is None:
            return 0
        raise TypeError(f"Unsupported proof type for size calculation: {type(proof)}") 