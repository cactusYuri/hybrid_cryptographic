from abc import ABC, abstractmethod
from typing import Any

class AccumulatorScheme(ABC):
    """
    Abstract Base Class for a cryptographic accumulator scheme.
    Defines the common interface for all schemes to be benchmarked.
    """

    @abstractmethod
    def __init__(self, state: list[bytes]):
        """
        Initializes the accumulator with a given state.
        
        :param state: A list of byte strings representing the initial state elements.
        """
        self.state = state
        self.accumulator = None
        self.prover_time = 0.0
        self.verifier_time = 0.0
        self.proof_size = 0

    @abstractmethod
    def create(self):
        """
        Creates the accumulator from the initial state.
        This method should be timed for benchmarking the prover's setup time.
        """
        pass

    @abstractmethod
    def prove_membership(self, element: bytes) -> Any:
        """
        Generates a membership proof for a given element.

        :param element: The element to prove membership for.
        :return: A proof object. The structure of this object is scheme-dependent.
        """
        pass

    @abstractmethod
    def verify_membership(self, element: bytes, proof: Any) -> bool:
        """
        Verifies a membership proof.

        :param element: The element whose membership is being verified.
        :param proof: The proof object generated by prove_membership.
        :return: True if the proof is valid, False otherwise.
        """
        pass

    @abstractmethod
    def update(self, additions: list[bytes], deletions: list[bytes]):
        """
        Updates the accumulator with additions and deletions.
        This method should also be timed to measure the prover's update overhead.

        :param additions: A list of elements to add to the state.
        :param deletions: A list of elements to remove from the state.
        """
        pass

    def get_proof_size(self, proof: Any) -> int:
        """
        Calculates the size of a proof in bytes.
        This is a default implementation that can be overridden if the proof
        is not a simple byte string or list of byte strings.
        """
        if isinstance(proof, bytes):
            return len(proof)
        if isinstance(proof, int):
            return (proof.bit_length() + 7) // 8
        if isinstance(proof, list):
            return sum(self.get_proof_size(p) for p in proof)
        if isinstance(proof, tuple):
             return sum(self.get_proof_size(p) for p in proof)
        if hasattr(proof, '__dict__'):
            return sum(self.get_proof_size(value) for value in proof.__dict__.values())
        if proof is None:
            return 0
        raise TypeError(f"Unsupported proof type for size calculation: {type(proof)}") 